use crypto_bigint::modular::Retrieve;
use crypto_bigint::{
    Bounded, Constants, FixedInteger, Integer, Monty, NonZero, Odd, PowBoundedExp, RandomBits, RandomMod, U1024, U128,
    U2048, U256, U4096, U512, U64,
};
use rand_core::CryptoRngCore;
#[cfg(feature = "default-rng")]
use rand_core::OsRng;
use tracing::trace;

use crate::hazmat::precomputed::SMALL_PRIMES;
use crate::is_prime;
/// Generate primes using a pseudo-uniform distribution.
/// Actors in this play are:
///     n:	the number of bits in the prime we're looking for, e.g. 512
///     l:	the number of top bits that are re-sampled on every iteration, e.g. 64
///     m:	a product of all small odd primes up to a bound ß chosen such that the bit size of m is n - l, e.g. ß = 512 - 64
///     b:	picked uniformely at random among integers less than m and coprime to m (use unit generation algorithm from JP06)
///     λ:	Carmichael's function: the LCM of the λ(p)s for each prime used to compute m. Each λ(p) is simply p-1 because each prime appears once and we exclude 2.

// TODO(dp): Proper docs here, explaining when this is useful and why, discussion about the distribution quality etc.
// TODO(dp): The `l` value isn't used anywhere and instead I'm assuming we want to re-sample
// `T::BITS/2` bits on every iteration, so for a 128-bit prime, resample 64 bits. I think this is
// way too much, but need more benchmarking + statistics to know what a "good" value actually means.
pub trait UniformGeneratePrime<T>
where
    T: Integer + Constants + Bounded + RandomBits + RandomMod + Copy,
{
    /// Returns a random prime using the provided RNG.
    ///
    /// See [`is_prime_with_rng`][crate::presets::is_prime_with_rng] for details about the performed checks.
    fn generate_prime_with_rng(rng: &mut impl CryptoRngCore) -> T;

    /// Returns a random prime using [`OsRng`] as the RNG.
    ///
    /// See [`is_prime_with_rng`][crate::presets::is_prime_with_rng] for details about the performed checks.
    #[cfg(feature = "default-rng")]
    fn generate_prime() -> T;

    // TODO(dp): missing
    // generate_safe_prime
    // generate_safe_prime_with_rng
}

macro_rules! impl_generate_prime {
    ($(($name:ident, $m:expr, $lambda_m:expr, $a_max:expr)),+) => {
        $(
            impl UniformGeneratePrime<$name> for $name {
                fn generate_prime_with_rng(rng: &mut impl CryptoRngCore) -> Self {
                    const M: $name = $name::from_be_hex($m);
                    const LAMBDA_M: $name = $name::from_be_hex($lambda_m);
                    const A_MAX: $name = $name::from_be_hex($a_max);
                    let unit = jp06_unitgen(rng, M, LAMBDA_M);
                    let a_max = NonZero::new(A_MAX).expect("A_MAX is pre-calculated and known-good");
                    // algorithm2_faster_but_why(rng, unit, M, &a_max)
                    algorithm2(rng, unit, M, &a_max).0

                }

                #[cfg(feature = "default-rng")]
                fn generate_prime() -> Self {
                    Self::generate_prime_with_rng(&mut OsRng)
                }
            }
        )+

    };
}

// `uint type`, `m`, `λ(m)`, `a_max`
impl_generate_prime! {
    // Here `l` is 32, i.e. 32/2, i.e. using a 32 bit `m` and a 16 bit `λ(m)`
    (U64,   "00000017592B1B49", "000000000000D890", "000000000AF6E233")
    ,
    // Here `l` is 64, i.e. 128/2, i.e. using a 64 bit `m`, a 32 bit `λ(m)`, resulting in an `a_max` that fits in 64 bits
    (U128,  "00000000000000341DD47F9F45C500AF", "0000000000000000000000001CA73570", "000000000000000004E97D6751832168")
    ,
    // Here `l` is 128, i.e. 256/2, i.e. using a 128 bit `m` and a 64 bit `λ(m)`
    (U256,  "0000000000000011F29EDACF6E2E9A7C551B02D2F73F5BB75C429A6CC2E79B83",
            "000000000000000000000000000000000000000000000000004607AF4E8D0720",
            "0000000000000000000000000000000000000000000000000E437DB94E575A97")
    ,
    // Here `l` is 64, i.e. 512/8, i.e. using a 448 bit `m`, a 128 bit `λ(m)`, resulting in an `a_max` that fits in 64 bits
    (U512,  "00000000000000017C55C0F0A4177201114F0EE33F80274A3D96ACA2550BECC44E0A7D91FE964F9EB063A1988371CE58DBCE32B9F167C9555FA02A47B545338F",
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000272829291267EAF47536965B3B0AD1500",
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AC4FAEF0A02ACA2D")
    ,
    // Here `l` is 128 bits
    (U1024, "000000000000000000000000000001189C19EB3A9B2B5843BC37B89935A7674C049F9CC1A53369A9816FEDFCD77C3F08E2BD5C6C2CA347F79D7084B130FE218A5DB3EA4E6F59DEA66D0C4F10A505F6D89012FDA6074523288946AA0D99E8D3C260E55CC290D2296309E683227097D630616907CDA00E98E282CA4947B2DF5FD5",
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003296AB65EE7FC8301DE8B6043A557F0E74E6896BD07763EC5F1FED0B8D17DB00",
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E98C6C9A1095BDBEDCABF2E91FF580")
    // // Here `l` is 64, i.e. 1024/16, i.e. using a 960 bit `m` and a ~256 bit `λ(m)`, resulting in an `a_max` that fits in 64 bits
    // (U1024, "00000000000000016CC3AC9DC18F442E3F73D34147E253920667D800DA63CE9FEA167C22335097E1B207A8BAE729F4AB07F1BA5062481BC1166E2E5A42FF2393A9D7A7F5A195FB3FA7318A51407B138E9C8C54557AD65B9080FF8DB0F7672097CBC0DBC6EDA3CF451C20ACF1D003D909D87DA7BDA10D2C4772F7EEF762520D17",
    //         "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000291A6B42D1C7D2A7184D13E36F65773BBEFB4FA7996101300D49F09962A361F00",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B3AAAB7FFC52941B")
    ,
    // The performance of this algorithm sort of drops off a cliff for 2048 bit primes. I don't know why this is.
    // Trying different values for `l` (i.e. the number of bits that are re-randomized at each iteration), it seems like 256 bits (1/8) is the
    // most performant for U2048s. Oddly enough, doing the same for U1024 has next to no impact: using a 128 bit l is just as fast as a 64 bit l.
    // // 512 bit l
    // (U2048, "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000909DF3BB36070BD5C1441BC813D98D6080853FDBA0FEE05D4FC182A878C506B857AA7162E52E1E9D888B30561096AFE87E097CF50E1C3A301C13E5FEFF1237C75380E62017F2800D76E39EDA9F29853FF6E6DEC73ACFE5AD906903C952E279FE8D0328256F98EFDA5C0087748D5EBB17B1DF6448EC4F36B950C0BF1AFB75D299322F74ADD6D61D6F76025B4713662939BFFC90620AAD9AC12046C3A24E303DB8BDA1FDACF022B5DAE3D71382C0129A5EDC7C74C562BB4D36740D857D47F4564D5",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000093FAD55730DC98006815B7CDF6B0E531969BC5D3E802E8DD5C42F508FF40CD79A410B49F92C40ADF2B082C01900",
    //         "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C52B5E2306D5A52BE9EA6D07004E1265CFD9F9B459C0F8D388F9943C95329A66D02098C7BEE430B916E154169595E10A51FAC6DD27AD2BDF200EB40A7A0B291")
    // ,
    // 256 bit l
    (U2048, "00000000000000000000000000000000000000000000000000000000000000070B7591E346ADB31BED851EFAF6FF7D66BA22AA1AEA0B045A9DA441E2FF55D9128858064B239696B87148405574421EF22DA36551D9FFD5436E9B9FDD207097F6E4DCCC3D80FD521CAE4D2215E25DBDB7ED1B6C643C32A9580D2FEC4469E7A7B3D14DF663BADA182D73C95A151FE43A287D4051F7268D3DFE487AFF61ADA5325DD1E2C396F41659E986B854004ADF7A8CC79B16D6B8839F04CC7CF65BAF324B4B5C2556BD39D5F3E9459D63C1589311FB09235FEF44D924A92B68402C0163CE2DDAAF4DEF1BE229D5DD6FC133D056979F52F9501EE6B43BA35AB8A3E98768AFCF",
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002883750C43D3E221431D2F3346B9DBBCA0925E53BEF0E71921288DBCE29750A2BDDFF38AD4E99BCB2863981AD19B89E6145300",
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002456CC1F22AAAF792727EE82F3215B6098CB16E4A2B7E0239592B57926808660")
    ,
    // 128 bit l
    // (U2048, "0000000000000000000000000000036C6E3E13331EC5D79DF6E1F12D4902E52EBD74678CAD34836377EA3F6A7D98535DCC65584C96430DE3D89EEA5FE88736A988E75874E2611F2AA3C99150555A3E1182E47F11BB9EB2D91C889DBDA6FEA36073EEBEB093E2F516994336516084203898201A73FD1637632DC4A98D066988261CC95023087D7E3D42EF0690252173F1A4146B660A6A019379DF5262CA76A1A3693F5DAC4443009AFA505F992AC852CE0D87FE456E94052755FDDBE7603D9DD469FDDFDE07938684E62FE2DF0F03A7F587C5F664895882508170D56D37E47F0F28B4475707DB8239C1507721CD10E3B3BE6073144C01738A4F17E7216D4847E5",
    //         "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000013682DE4C81E1A88DA9A9C674E3B34E1FEDD57D8A8F9F52AA39390FFE682B454EC328F9A1C455977E59489DE32175FEED2696B12E43100",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004AC6A9A539EF07EDCED266DC673757")
    // ,
    // 64 bit l
    // (U2048, "00000000000001909190002281DD540A97C75CD9437C11261246ED261B4F9E467EC48C404B44EDE24657C959D9AE6B7D2B7EF2E5B14B0CFA491BA0810F5BCE7E107F553F03D7A446E6E343E8C86B3A4D87701051C4284B99560D6EAD50D763F6A5C7CDA39743CE511065C275A8B842A1ADF4BBB29A65C64218FB7F7772E4BD2E654596228EBD7FF6A7234C1B1661D99C2B34C74331039040D115DED7393D45C645DE7B39CC101F9FD0C578EA0BE2AA047F985EF51CE92CB73B5419DE7FA42D0257EFC6334626AB77238A06101543736D5153450091508DE67EE99AB09C4EDA04317AE14C4CFE1FB00412FFC86BDBFE9D0B277E6B8203E1A84C6DEB8F2393EC63",
    //         "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000368198E58E0C8C865DF83D4624B84986BACFA9B982960792C16B743EB869187A83620151D566C647BDCC2F370EAFA66FC0F613BA0EE59F00",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A39B8092511EC7")
    // ,
    // Here `l` is 2048, i.e. 4096/2, i.e. using a 2048 bit `m` and a 1024 bit `λ(m)`
    (U4096, "00000000000000037D9A60CA89EEF782BB9C56EFA01E68FC70C99F4409632932CFA5CFA14FCE39BA9513C7B9EF0E4221BCEAC67D9EEF8BC2F6EEB387DF68571DC3A11083AE28AEB577DCF7A4ED050E031ADC45B85B2BEA6419FFC330733F116237A75DDBA83EC2F6E1268DCEE6B85F4071AD6F04490C592113609C66DB31B91B24082F2382EB9ECD709237CE22AC5BA4FF4F65AF4425F611A89C566ED40A996216B0E4EC0A7E50CC7F82620697BE2A2142082E5E13EA97773B5C694FF63FC3827A4DF419D22F4C390008A7EAFB2B756CADEEF062E06849A0ECB760E8A2B4DFD74D32B13064A8C4D2C001A842128133F9CEA3D7CA30C8F24DFCAD1E976F0EC4A573FD0CDEC198C81F2D2025ED3B625348D5F7FFC7248C312B99707E0A43744A1BA9D268B4A4F7949239BBEDCD5DE5108C1503F5CEE6E38C05169AF3660CA4645E1EB78AF99BDA3020BEAD0DD6DAD20BF95537E541973D0485F273EDB09895B940D95FCB07AFF5DE297E84FA59E376BF4A51686FB2E097DBA76AB4AEEBAE2FDE0CC457594AC087AF175941A0A917F7B18FCF0288FF3E323BC0BE5CF76106FF9B8D28033659514A5B629638225B5338242266D1CAD602647013B6AE1A656438429FB27F2CC05F77DB885AA8CDC1B87AF98E1A931E08244F041004C7B39F939A7C78D0B2052278CB715B4634B3D4312B0FE9690E748CF04A95FE026FB6304F90019B",
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000058D1379342EF74FD8B9FB6FBC9DA6E02A86239D09BB185855CD437E82744A62907F668922B2D4F64924BF9D051DC21D8F59EBAEAC700971049C3448BAFEC1E2FB964A1CF46A490A0D5A4B4C525D84588010687648730D8FB6CC6CBE50CF1B39909DE4CBE7102B00",
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004956CC20DCA5AFF5")
}

// From https://marcjoye.github.io/papers/JP06pgen.pdf, page 6, fig. 4
// Parameters: m and λ(m)
// Output: a random unit k ∈ (Z/mZ)∗
// 1. Randomly choose k ∈ [1, m[
// 2. Set U ← (1 − kλ(m)) mod m
// 3. If (U ! = 0) then
//  (a) Choose a random r ∈ [1, m[
//  (b) Set k ← k + rU (mod m)
//  (c) Go to Step 2
// 4. Output k
// TODO(dp): probably unify this with "algorithm2" yeah?
#[allow(unused)]
#[inline(always)]
fn jp06_unitgen<T>(rng: &mut impl CryptoRngCore, m: T, lambda_m: T) -> T
where
    T: FixedInteger + RandomBits,
    T::Monty: Retrieve<Output = T> + Copy,
    <<T as Integer>::Monty as Monty>::Params: Copy,
{
    // 1. sample k in [1, m[
    let m_bits = m.bits_vartime();
    let mut k = T::random_bits(rng, m_bits);
    while k >= m {
        k = T::random_bits(rng, m_bits);
    }
    // 2. set `u = 1-(k^lambda_m) mod m`
    let prms = <T as Integer>::Monty::new_params_vartime(
        Odd::new(m).expect("m is a known, pre-calculated, non-zero, odd value"),
    );
    let one = T::Monty::one(prms);
    let zero = T::Monty::zero(prms);
    let m_monty_plus_one = T::Monty::new(m, prms) + one;

    let mut k = T::Monty::new(k, prms);
    let mut u = m_monty_plus_one - k.pow_bounded_exp(&lambda_m, lambda_m.bits_vartime());

    // if u != 0 {
    // 	pick random r from [1,m[
    // 	k = k + r*u mod m
    // 	go to step 2
    // }
    while u != zero {
        let mut r = T::random_bits(rng, m_bits);
        while r >= m {
            r = T::random_bits(rng, m_bits);
        }
        let r = T::Monty::new(r, prms);
        k = k + r * u;
        u = m_monty_plus_one - k.pow_bounded_exp(&lambda_m, lambda_m.bits_vartime());
    }
    k.retrieve()
}

// From https://eprint.iacr.org/2011/481.pdf, page 4:
// Algorithm 2 More eﬃcient method
// 1:   b $← {1,…, m−1}
// 2:   u ← (1−b^λ(m)) mod m
// 3:   if u != 0 then
// 4:       r $← {1,…, m−1}
// 5:       b ← b + ru mod m
// 6:       goto step 2
// 7:   end if
// 8:   repeat
// 9:       a $← {0,…, ⌊2^n/m⌋−1}
// 10:      p ← am + b
// 11:  until p is prime
// 12:  return p
// NOTE: Steps 1-7 are implemented in `jp06_unitgen`, where `b` is referred to as `k`.
// TODO(dp): probably should unify the two functions.
#[allow(unused)]
#[inline(always)]
fn algorithm2<T>(rng: &mut impl CryptoRngCore, b: T, m: T, a_max: &NonZero<T>) -> (T, u64)
where
    T: Integer + Constants + RandomMod + Copy + Bounded,
{
    let mut a = T::random_mod(rng, a_max);
    let mut p = a * m + b;
    let mut primality_tests = 1;
    while !is_prime(&p) {
        a = T::random_mod(rng, a_max);
        p = a * m + b;
        primality_tests += 1;
    }
    trace!("[algo2-a] {} bits. Needed {} primality tests", T::BITS, primality_tests);
    (p, primality_tests)
}

// TODO(dp): Why is this faster? Is something wrong here? It's almost exactly 4x faster than the correct version.
// It seems like `T::random_mod` is a lot slower than `T::random_bits` + bounds check&retries. A regression? Expected?
#[allow(unused)]
#[inline(always)]
fn algorithm2_faster_but_why<T>(rng: &mut impl CryptoRngCore, b: T, m: T, a_max: &NonZero<T>) -> (T, u64)
where
    T: Integer + Bounded + RandomBits + RandomMod + Copy,
{
    let a_max = a_max.get();
    let a_max_bits = a_max.bits_vartime();
    let mut a = T::random_bits(rng, a_max_bits);
    while a >= a_max {
        a = T::random_bits(rng, a_max_bits);
    }

    let mut p = a * m + b;
    let mut primality_tests = 1;
    while !is_prime(&p) {
        a = T::random_bits(rng, a_max_bits);
        while a >= a_max {
            a = T::random_bits(rng, a_max_bits);
        }
        p = a * m + b;
        primality_tests += 1;
    }
    trace!("[algo2-b] {} bits. Needed {} primality tests", T::BITS, primality_tests);
    (p, primality_tests)
}

// Calculates three constants, `m`, `λ(m)` and `a_max`, used in the uniform sieving algorithms.
// `m` is the product of all odd primes such that the product fits in a `T`.
// `λ(m)`, aka Carmichael's function is the LCM of the λ(p)s for each prime used to compute m. In
// our case, each λ(p) is simply p-1 because each prime appears once (and we exclude 2).
// `a_max` is the upper bound on the part of a prime candidate that is re-randomized on each iteration and set to 2^n/m -1
// Find constant values for common `T`s sized from 64 to 4096 in the test `generate_constants`.
#[allow(unused)]
fn calculate_constants<T>() -> (T, T, T)
where
    T: FixedInteger + crypto_bigint::Gcd<Output = T>,
{
    let mut m = T::ONE;
    let mut lambda_m = T::ONE;

    let a_max_bits = if T::BITS > 64 { 64 } else { 32 };
    for (i, prime) in SMALL_PRIMES.iter().enumerate() {
        let prime_t = T::from(*prime);
        let prod_overflowed = m.checked_mul(&prime_t);

        let a_max = T::MAX.div(NonZero::new(m).unwrap()) - T::ONE;

        if prod_overflowed.is_none().into() {
            trace!(
                "{} bits: Stopping after {} iterations, because prime={} overflows m. Last prime in m is {}",
                T::BITS,
                i - 1,
                prime,
                SMALL_PRIMES[i - 1]
            );
            break;
        } else if a_max.bits_vartime() <= a_max_bits {
            trace!(
                "{} bits: Stopping after {} iterations, because prime={} would make a_max bigger than {a_max_bits} bits. Last prime in m is {}",
                T::BITS, i-1, prime, SMALL_PRIMES[i - 1]
            );
            break;
        } else {
            m = prod_overflowed.unwrap();
            let p_minus_one = prime_t - T::ONE;
            let gcd = lambda_m.gcd(&p_minus_one);
            let gcd_nz = NonZero::new(gcd).unwrap();
            lambda_m = lambda_m * prime_t.div(gcd_nz);
        }
    }
    trace!(
        "{} bits: dividing T::MAX with m={m:?} that has {} bits and {} leading zeros.",
        T::BITS,
        m.bits_vartime(),
        m.leading_zeros()
    );

    let a_max = T::MAX.div(NonZero::new(m).unwrap()) - T::ONE;
    trace!(
        "{} bits: a_max={a_max:?}, has {} bits and {} leading zeros.",
        T::BITS,
        a_max.bits_vartime(),
        a_max.leading_zeros()
    );
    (m, lambda_m, a_max)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crypto_bigint::{U1024, U128, U2048, U256, U512, U64};
    use rand::SeedableRng;
    use rand_chacha::ChaCha8Rng;
    use tracing::{debug, info};

    #[ignore = "not an actual test"]
    #[test_log::test]
    fn debug_jp06() {
        type T = U1024;
        let mut rng = ChaCha8Rng::from_seed(*b"01234567890123456789012345678901");
        // let hex_m = "00000017592B1B49";
        // let hex_lambda_m = "000000000000D890";
        let hex_m =
        "00000000000000016CC3AC9DC18F442E3F73D34147E253920667D800DA63CE9FEA167C22335097E1B207A8BAE729F4AB07F1BA5062481BC1166E2E5A42FF2393A9D7A7F5A195FB3FA7318A51407B138E9C8C54557AD65B9080FF8DB0F7672097CBC0DBC6EDA3CF451C20ACF1D003D909D87DA7BDA10D2C4772F7EEF762520D17";
        let hex_lambda_m =
        "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000291A6B42D1C7D2A7184D13E36F65773BBEFB4FA7996101300D49F09962A361F00";
        let m = T::from_be_hex(hex_m);
        let lambda_m = T::from_be_hex(hex_lambda_m);

        let mut count = 0u64;
        let rep = 100;
        let mut start = std::time::Instant::now();
        loop {
            let _unit = jp06_unitgen(&mut rng, m, lambda_m);
            count += 1;
            if count % rep == 0 {
                info!("{rep} iters in {:?}", start.elapsed());
                start = std::time::Instant::now();
            }
        }
    }

    #[ignore = "not an actual test"]
    #[test_log::test]
    fn debug_algo2() {
        type T = U1024;
        let mut rng = ChaCha8Rng::from_seed(*b"01234567890123456789012345678901");
        let mut rng1 = ChaCha8Rng::from_seed(*b"01234567890123456789012345678901");
        let mut rng2 = ChaCha8Rng::from_seed(*b"01234567890123456789012345678901");
        // U1024
        let hex_m = "00000000000000016CC3AC9DC18F442E3F73D34147E253920667D800DA63CE9FEA167C22335097E1B207A8BAE729F4AB07F1BA5062481BC1166E2E5A42FF2393A9D7A7F5A195FB3FA7318A51407B138E9C8C54557AD65B9080FF8DB0F7672097CBC0DBC6EDA3CF451C20ACF1D003D909D87DA7BDA10D2C4772F7EEF762520D17";
        let hex_lambda_m = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000291A6B42D1C7D2A7184D13E36F65773BBEFB4FA7996101300D49F09962A361F00";
        let a_max = T::from_be_hex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B3AAAB7FFC52941B");
        // U128
        // let hex_m = "00000000000000341DD47F9F45C500AF";
        // let hex_lambda_m = "0000000000000000000000001CA73570";
        // let a_max = T::from_be_hex("000000000000000004E97D6751832168");
        // U64
        // let hex_m = "00000017592B1B49";
        // let hex_lambda_m = "000000000000D890";
        // let a_max = T::from_be_hex("000000000AF6E233");
        let m = T::from_be_hex(hex_m);
        let lambda_m = T::from_be_hex(hex_lambda_m);
        let unit = jp06_unitgen(&mut rng, m, lambda_m);

        let mut count = 0u64;
        let a_max_nz = NonZero::new(a_max).expect("m is known, pre-calculated, non-zero, odd, larger than 1");
        info!("T::BITS={}, a_max={a_max:?} ", T::BITS);
        let mut tests_algo2_a = 0;
        let mut tests_algo2_b = 0;
        let mut start = std::time::Instant::now();
        loop {
            // This is 4x faster than `algorithm2`
            let (a1, tests_a) = algorithm2(&mut rng1, unit, m, &a_max_nz);
            let (a2, tests_b) = algorithm2_faster_but_why(&mut rng2, unit, m, &a_max_nz);
            debug!("algo2-a:\t{a1:?}, tests={tests_a}");
            debug!("algo2-b:\t{a2:?}, tests={tests_b}");
            count += 1;
            tests_algo2_a += tests_a;
            tests_algo2_b += tests_b;
            if count % 100 == 0 {
                info!("{count} iters in {:?}", start.elapsed());
                info!("algo2-a:\tprimality tests: {}", tests_algo2_a / count);
                info!("algo2-b:\tprimality tests: {}", tests_algo2_b / count);
                start = std::time::Instant::now();
            }
        }
    }

    // This isn't actually a test, just here to generate constants
    #[ignore = "not an actual test"]
    #[test_log::test]
    fn generate_constants() {
        let (m, lambda_m, a_max) = calculate_constants::<U64>();
        info!("64 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}");
        assert_eq!(m, U64::from_be_hex("00000017592B1B49"));
        assert_eq!(lambda_m, U64::from_be_hex("000000000000D890"));
        assert_eq!(a_max, U64::from_be_hex("000000000AF6E233"));

        let (m, lambda_m, a_max) = calculate_constants::<U128>();
        info!("128 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}");
        assert_eq!(m, U128::from_be_hex("00000000000000341DD47F9F45C500AF"));
        assert_eq!(lambda_m, U128::from_be_hex("0000000000000000000000001CA73570"));
        assert_eq!(a_max, U128::from_be_hex("000000000000000004E97D6751832168"));

        let (m, lambda_m, a_max) = calculate_constants::<U256>();
        info!("256 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}",);
        assert_eq!(
            m,
            U256::from_be_hex("0000000000000011F29EDACF6E2E9A7C551B02D2F73F5BB75C429A6CC2E79B83")
        );
        assert_eq!(
            lambda_m,
            U256::from_be_hex("000000000000000000000000000000000000000000000000004607AF4E8D0720")
        );
        assert_eq!(
            a_max,
            U256::from_be_hex("0000000000000000000000000000000000000000000000000E437DB94E575A97")
        );

        let (m, lambda_m, a_max) = calculate_constants::<U512>();
        info!("512 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}");
        assert_eq!(m, U512::from_be_hex("00000000000000017C55C0F0A4177201114F0EE33F80274A3D96ACA2550BECC44E0A7D91FE964F9EB063A1988371CE58DBCE32B9F167C9555FA02A47B545338F"));
        assert_eq!(lambda_m, U512::from_be_hex("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000272829291267EAF47536965B3B0AD1500"));
        assert_eq!(a_max, U512::from_be_hex("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AC4FAEF0A02ACA2D"));

        let (m, lambda_m, a_max) = calculate_constants::<U1024>();
        info!("1024 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}");
        assert_eq!(m, U1024::from_be_hex("00000000000000016CC3AC9DC18F442E3F73D34147E253920667D800DA63CE9FEA167C22335097E1B207A8BAE729F4AB07F1BA5062481BC1166E2E5A42FF2393A9D7A7F5A195FB3FA7318A51407B138E9C8C54557AD65B9080FF8DB0F7672097CBC0DBC6EDA3CF451C20ACF1D003D909D87DA7BDA10D2C4772F7EEF762520D17"));
        assert_eq!(lambda_m, U1024::from_be_hex("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000291A6B42D1C7D2A7184D13E36F65773BBEFB4FA7996101300D49F09962A361F00"));
        assert_eq!(a_max, U1024::from_be_hex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B3AAAB7FFC52941B"));

        let (m, lambda_m, a_max) = calculate_constants::<U2048>();
        info!("2048 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}");
        assert_eq!(m, U2048::from_be_hex("00000000000001909190002281DD540A97C75CD9437C11261246ED261B4F9E467EC48C404B44EDE24657C959D9AE6B7D2B7EF2E5B14B0CFA491BA0810F5BCE7E107F553F03D7A446E6E343E8C86B3A4D87701051C4284B99560D6EAD50D763F6A5C7CDA39743CE511065C275A8B842A1ADF4BBB29A65C64218FB7F7772E4BD2E654596228EBD7FF6A7234C1B1661D99C2B34C74331039040D115DED7393D45C645DE7B39CC101F9FD0C578EA0BE2AA047F985EF51CE92CB73B5419DE7FA42D0257EFC6334626AB77238A06101543736D5153450091508DE67EE99AB09C4EDA04317AE14C4CFE1FB00412FFC86BDBFE9D0B277E6B8203E1A84C6DEB8F2393EC63"));
        assert_eq!(lambda_m, U2048::from_be_hex("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000368198E58E0C8C865DF83D4624B84986BACFA9B982960792C16B743EB869187A83620151D566C647BDCC2F370EAFA66FC0F613BA0EE59F00"));
        assert_eq!(a_max, U2048::from_be_hex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A39B8092511EC7"));

        let (m, lambda_m, a_max) = calculate_constants::<U4096>();
        info!("4096 bits: \nm={m:?}, \nlambda_m={lambda_m:?}, \na_max={a_max:?}");
        assert_eq!(m, U4096::from_be_hex("00000000000000037D9A60CA89EEF782BB9C56EFA01E68FC70C99F4409632932CFA5CFA14FCE39BA9513C7B9EF0E4221BCEAC67D9EEF8BC2F6EEB387DF68571DC3A11083AE28AEB577DCF7A4ED050E031ADC45B85B2BEA6419FFC330733F116237A75DDBA83EC2F6E1268DCEE6B85F4071AD6F04490C592113609C66DB31B91B24082F2382EB9ECD709237CE22AC5BA4FF4F65AF4425F611A89C566ED40A996216B0E4EC0A7E50CC7F82620697BE2A2142082E5E13EA97773B5C694FF63FC3827A4DF419D22F4C390008A7EAFB2B756CADEEF062E06849A0ECB760E8A2B4DFD74D32B13064A8C4D2C001A842128133F9CEA3D7CA30C8F24DFCAD1E976F0EC4A573FD0CDEC198C81F2D2025ED3B625348D5F7FFC7248C312B99707E0A43744A1BA9D268B4A4F7949239BBEDCD5DE5108C1503F5CEE6E38C05169AF3660CA4645E1EB78AF99BDA3020BEAD0DD6DAD20BF95537E541973D0485F273EDB09895B940D95FCB07AFF5DE297E84FA59E376BF4A51686FB2E097DBA76AB4AEEBAE2FDE0CC457594AC087AF175941A0A917F7B18FCF0288FF3E323BC0BE5CF76106FF9B8D28033659514A5B629638225B5338242266D1CAD602647013B6AE1A656438429FB27F2CC05F77DB885AA8CDC1B87AF98E1A931E08244F041004C7B39F939A7C78D0B2052278CB715B4634B3D4312B0FE9690E748CF04A95FE026FB6304F90019B"));
        assert_eq!(lambda_m, U4096::from_be_hex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000058D1379342EF74FD8B9FB6FBC9DA6E02A86239D09BB185855CD437E82744A62907F668922B2D4F64924BF9D051DC21D8F59EBAEAC700971049C3448BAFEC1E2FB964A1CF46A490A0D5A4B4C525D84588010687648730D8FB6CC6CBE50CF1B39909DE4CBE7102B00"));
        assert_eq!(a_max, U4096::from_be_hex("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004956CC20DCA5AFF5"));
    }

    #[test_log::test]
    fn genprime() {
        let p: U64 = U64::generate_prime();
        info!("64 bit prime={p:?}");
        let p = U128::generate_prime();
        info!("128 bit prime={p:?}");
        let p = U256::generate_prime();
        info!("256 bit prime={p:?}");
        let p = U512::generate_prime();
        info!("512 bit prime={p:?}");
        let p = U1024::generate_prime();
        info!("1024 bit prime={p:?}");
        let p = U2048::generate_prime();
        info!("2048 bit prime={p:?}");
        // This is very slow
        // let p = U4096::generate_prime();
        // info!("4096 bit prime={p:?}");
    }

    // TODO(dp): test for statistical properties
    #[ignore = "tbd"]
    #[test_log::test]
    fn entropy() {
        // Let x = 2^k, and let Mk be the set of odd numbers in the interval [x/2..x[, i.e. the set
        // of odd numbers of bit length precisely k.
        // The optimal output distribution of primes is the uniform distribution over the primes in Mk, since
        // it has maximal entropy. By the prime number theorem, this maximal value is about
        //      Hmax(x) = log(x/(2*log(x)) for large x.

        // Theorem 1.
        // Let H be the entropy of the output distribution.
        // Let Hmax be the maximal possible value of H.
        // Then, under Hardy and Littlewoods’ prime r-tuple conjecture[11] and Gallagher’s
        // heuristic[10], we have for any n >= 256:
        //      Hmax − H < (1−γ) / ln 2 < 0.609949
        // where γ is the Euler-Mascheroni constant[22].
    }
}
