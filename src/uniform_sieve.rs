use crypto_bigint::modular::Retrieve;
use crypto_bigint::{
    Bounded, Constants, FixedInteger, Integer, Monty, NonZero, Odd, PowBoundedExp, RandomBits, RandomMod, U1024, U128,
    U2048, U256, U4096, U512, U64,
};
use rand::thread_rng;

use crate::hazmat::precomputed::SMALL_PRIMES;
use crate::{hazmat::binary_gcd, is_prime};
/// Generate primes using a pseudo-uniform distribution.
/// Actors in this play are:
///     n:	the number of bits in the prime we're looking for, e.g. 512
///     l:	the number of top bits that are re-sampled on every iteration, e.g. 64
///     m:	a product of all small odd primes up to a bound ß chosen such that the bit size of m is n - l, e.g. ß = 512 - 64
///     b:	picked uniformely at random among integers less than m and coprime to m (use unit generation algorithm from JP06)
///     λ:	Carmichael's function: the LCM of the λ(p)s for each prime used to compute m. Each λ(p) is simply p-1 because each prime appears once and we exclude 2.

// TODO(dp): Proper docs here, explaining when this is useful and why, discussion about the distribution quality etc.
// TODO(dp): The `l` value isn't used anywhere and instead I'm assuming we want to re-sample
// `T::BITS/2` bits on every iteration, so for a 128-bit prime, resample 64 bits. I think this is
// way too much, but need more benchmarking + statistics to know what a "good" value actually means.
pub trait UniformGeneratePrime<T>
where
    T: Integer + Constants + Bounded + RandomBits + RandomMod + Copy,
{
    /// Generate a prime.
    fn generate_prime() -> T;
    // TODO(dp): missing
    // generate_prime_with_rng
    // generate_safe_prime
    // generate_safe_prime_with_rng
}

macro_rules! impl_generate_prime {
    ($(($name:ident, $m:expr, $lambda_m:expr, $a_max:expr)),+) => {
        $(
            impl UniformGeneratePrime<$name> for $name {
                fn generate_prime() -> $name {
                    debug_assert!($m.len() == (2*$name::BITS/8) as usize, "expected m to be {} long, instead it's {}", 2*$name::BITS/8, $m.len());
                    const M: $name = $name::from_be_hex($m);
                    const LAMBDA_M: $name = $name::from_be_hex($lambda_m);
                    const A_MAX: $name = $name::from_be_hex($a_max);
                    let unit = jp06_unitgen(M, LAMBDA_M);
                    let a_max = NonZero::new(A_MAX).expect("A_MAX is pre-calculated and known-good");
                    algorithm2_faster_but_why(unit, M, &a_max)
                    // algorithm2(unit, M, &a_max)

                }
            }
        )+

    };
}

impl_generate_prime! {
    // Here `l` is 32, i.e. 32/2, i.e. using a 32 bit `m` and a 16 bit `λ(m)`
    (U64,   "00000000C0CFD797", "000000000000D890", "0000000153E5645B")
    ,
    // Here `l` is 32, i.e. 128/4, i.e. using a 32 bit `m` and a 16 bit `λ(m)`
    (U128,  "000000000000000000000000C0CFD797", "0000000000000000000000000000D890", "00000000000000000000000153E5645B")
    // // Here `l` is 64, i.e. 128/2, i.e. using a 64 bit `m` and a 32 bit `λ(m)`
    // (U128,  "0000000000000000E221F97C30E94E1D", "00000000000000000000000000FCF030", "000000000000000121CFE6CFC938B36A")
    ,
    // Here `l` is 128, i.e. 256/2, i.e. using a 128 bit `m` and a 64 bit `λ(m)`
    (U256,  "000000000000000000000000000000005797D47C51681549D734E4FC4C3EAF7F",
            "0000000000000000000000000000000000000000000000000000002DE3CB9560",
            "00000000000000000000000000000002EC2FD90EC0982A01049B71B59E0BEBD7")
    ,
    // Here `l` is 256, i.e. 512/2, i.e. using a 256 bit `m` and a 128 bit `λ(m)`
    (U512,  "0000000000000000000000000000000000000000000000000000000000000000DBF05B6F5654B3C0F5243551439586889F155887819AED2AC05B93352BE98677",
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000097262FAE1826B96DBE40",
            "000000000000000000000000000000000000000000000000000000000000000129F942811E1964B5B00B0B16015A8EEA88C7191B2E972CC3A9C9F1BD3BF4A01C")
    ,
    // Here `l` is 128, i.e. 1024/8, i.e. using a 128 bit `m` and a 64 bit `λ(m)`
    (U1024, "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005797D47C51681549D734E4FC4C3EAF7F",
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002DE3CB9560",
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002EC2FD90EC0982A01049B71B59E0BEBD7")
    // Here `l` is 512, i.e. 1024/2, i.e. using a 512 bit `m` and a 128 bit `λ(m)`
    // (U1024, "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000106AA9FB7646FA6EB0813C28C5D5F09F077EC3BA238BFB99C1B631A203E81187233DB117CBC384056EF04659A4A11DE49F7ECB29BADA8F980DECECE92E30C48F",
    //         "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000468A4F19CEA99B05F593F7F03EBA946B4AF700",
    //         "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F980B0BC8CD6E718FFDE5AE0714973483A90B31703570FD0F4D3AF75B7A104188AAFF383B6267C09BDEDC4E3C889A46D39E0E4ABC82611D46631FD36F36B760B7")
    ,
    // Here `l` is 256, i.e. 2048/8, i.e. using a 256 bit `m` and a 128 bit `λ(m)`
    (U2048, "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000DBF05B6F5654B3C0F5243551439586889F155887819AED2AC05B93352BE98677",
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000097262FAE1826B96DBE40",
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000129F942811E1964B5B00B0B16015A8EEA88C7191B2E972CC3A9C9F1BD3BF4A01C")
    // Here `l` is 1024, i.e. 2048/2, i.e. using a 1024 bit `m` and a 512 bit `λ(m)`
    // (U2048, "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002C85FF870F24BE80F62B1BA6C20BD72B837EFDF121206D87DB56B7D69FA4C021C107C3CA206FE8FA7080EF576EFFC82F9B10F5750656B7794B16AFD70996E91AEF6E0AD15E91B071AC9B24D98B233AD86EE055518E58E56638EF18BAC5C74CB35BBB6E5DAE2783DD1C0CE7DEC4FC70E5186D411DF36368F061AA36011F30179",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009220E37A82CBB6007A9DEE07DE852B1FD11D7594688264F7F40E71355F33B7EBFC100",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005BFF1AFC23D09D75DEDE879115527714867E2D48B0A105AC642B99C0B539A8331BCD4ADC7FE2B37FD0E1D5422305EE5CDE57882ACF567FC77E6847C47ED3802E74EE0C05F9E5727E4797737D9A5B5FF10BC23BCCA027A43EC75D8F115677DA1F650DF093CA66A0FB46357E0EE79B50C2381EC61CB4F2250EED7FB80DDD219F86AE")
    ,
    // Here `l` is 512, i.e. 4096/8, i.e. using a 512 bit `m` and a 256 bit `λ(m)`
    (U4096, "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000106AA9FB7646FA6EB0813C28C5D5F09F077EC3BA238BFB99C1B631A203E81187233DB117CBC384056EF04659A4A11DE49F7ECB29BADA8F980DECECE92E30C48F",
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000468A4F19CEA99B05F593F7F03EBA946B4AF700",
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F980B0BC8CD6E718FFDE5AE0714973483A90B31703570FD0F4D3AF75B7A104188AAFF383B6267C09BDEDC4E3C889A46D39E0E4ABC82611D46631FD36F36B760B7")
    // Here `l` is 2048, i.e. 4096/2, i.e. using a 2048 bit `m` and a 1024 bit `λ(m)`
    // (U4096, "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002465A7BD85011E1C9E0527929FFF268C82EF7EFA416863BAA5ACDB0971DBA0CCAC3EE4999345029F2CF810B99E406AAC5FCE5DD69D1C717DAEA5D18AB913F456505679BC91C57D46D9888857862B36E2EDE2E473C1F0AB359DA25271AFFE15FF240E299D0B04F4CD0E4D7C0E47B1A7BA007DE89AAE848FD5BDCD7F9815564EB060AE14F19CB50C291F0BBD8ED1C4C7F8FC5FBA51662001939B532D92DAC844A8431D400C832D039F5F900B278A75219C2986140C79045D7759540854C31504DC56F1DF5EEBE7BEE447658B917BF696D6927F2E2428FBEB340E515CB9835D63871BE8BBE09CF13445799F2E67788151571A93B4C1EEE55D1B9072E0B2F5C4607F",
    //         "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000099F002D0502D70DF7B64150D19B477A781987C56EBCDB7637842794D22D0D022010DC9BA1DB141FC9D07A9587E7A130D9DF6F9B67812800D00",
    //         "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000708955E50C5F9A609A797793B1E155517918D6A5537DC62F21D44D8DE025D4D2936ED0EC76AB086E7725EF62D185C61607BF006F017521BE5C249C24A6809A2B389BB614AFD09A32FB39B58881869396DFE87BC8957BBBE2EE8E7E0B551B0EC3C93DB35A95C541637D3A2566DECCA46512BA640192980BD5EE0619E8790206EE416F78E6B7B0AAE3C90A195A574663F9BAE4195B0DA9F0C73843460F4B0068747B57FDE77319FF7CE46A7039137FA7FB58FE0F88B964CAF66038843AA52A0114105118DFF6BD50C40FBBFF9FA5CBB181EE3D7AD3D055C5A85B49CFD989AC31B3338C3DF660C708AEB65376D65B67C1580436235BDA8CC5989BD4102900150626A")
}

// From https://marcjoye.github.io/papers/JP06pgen.pdf, page 6, fig. 4
// Parameters: m and λ(m)
// Output: a random unit k ∈ (Z/mZ)∗
// 1. Randomly choose k ∈ [1, m[
// 2. Set U ← (1 − kλ(m)) mod m
// 3. If (U ! = 0) then
//  (a) Choose a random r ∈ [1, m[
//  (b) Set k ← k + rU (mod m)
//  (c) Go to Step 2
// 4. Output k
// TODO(dp): probably unify this with "algorithm2" yeah?
#[inline(always)]
fn jp06_unitgen<T>(m: T, lambda_m: T) -> T
where
    T: FixedInteger + RandomMod,
    T::Monty: Retrieve<Output = T> + Copy,
    <<T as Integer>::Monty as Monty>::Params: Copy,
{
    let mut rng = thread_rng();
    // 1. sample k in [1, m[
    let m_nz = NonZero::new(m - T::ONE).expect("m is a known, pre-calculated non-zero value");
    // TODO(dp): can this also be sped up 4x by switching to random_bits + bound-check&retries?
    let k = T::random_mod(&mut rng, &m_nz) + T::ONE;

    // 2. set `u = 1-(k^lambda_m) mod m`; rewrite as `(1 - k^lambda_m + m) mod m` if k^lambda_m < m, else compute (k^lambda_m) mod m
    let prms = <T as Integer>::Monty::new_params_vartime(
        Odd::new(m).expect("m is a known, pre-calculated, non-zero, odd value"),
    );
    let one = T::Monty::one(prms);
    let zero = T::Monty::zero(prms);

    let mut k = T::Monty::new(k, prms);
    let mut u = one - k.pow_bounded_exp(&lambda_m, 32);

    // if u != 0 {
    // 	pick random r from [1,m[
    // 	k = k + r*u mod m
    // 	go to step 2
    // }
    while u != zero {
        // TODO(dp): can this also be sped up 4x by switching to random_bits + bound-check&retries?
        let r = T::random_mod(&mut rng, &m_nz) + T::ONE;
        let r = T::Monty::new(r, prms);
        k = k + r * u;
        u = one - k.pow_bounded_exp(&lambda_m, 32);
    }
    k.retrieve()
}

// From https://eprint.iacr.org/2011/481.pdf, page 4:
// Algorithm 2 More eﬃcient method
// 1:   b $← {1,…, m−1}
// 2:   u ← (1−b^λ(m)) mod m
// 3:   if u != 0 then
// 4:       r $← {1,…, m−1}
// 5:       b ← b + ru mod m
// 6:       goto step 2
// 7:   end if
// 8:   repeat
// 9:       a $← {0,…, ⌊2^n/m⌋−1}
// 10:      p ← am + b
// 11:  until p is prime
// 12:  return p
// NOTE: Steps 1-7 are implemented in `jp06_unitgen`, where `b` is referred to as `k`.
// TODO(dp): probably should unify the two functions.
#[allow(unused)]
#[inline(always)]
fn algorithm2<T>(b: T, m: T, a_max: &NonZero<T>) -> T
where
    T: Integer + Constants + RandomMod + Copy,
{
    let mut rng = thread_rng();
    let mut a = T::random_mod(&mut rng, a_max);
    let mut p = a * m + b;
    while !is_prime(&p) {
        a = T::random_mod(&mut rng, a_max);
        p = a * m + b;
    }
    p
}

// TODO(dp): Why is this faster? Is something wrong here? It's almost exactly 4x faster than the correct version.
// It seems like `T::random_mod` is a lot slower than `T::random_bits` + bounds check&retries. A regression? Expected?
#[allow(unused)]
#[inline(always)]
fn algorithm2_faster_but_why<T>(b: T, m: T, a_max: &NonZero<T>) -> T
where
    T: Integer + Bounded + RandomBits + RandomMod + Copy,
{
    let mut rng = thread_rng();
    let a_max_bits = T::BITS - m.leading_zeros();
    let mut a = T::random_bits(&mut rng, a_max_bits);
    while a >= a_max.get() {
        a = T::random_bits(&mut rng, a_max_bits)
    }
    let mut p = a * m + b;
    while !is_prime(&p) {
        a = T::random_bits(&mut rng, a_max_bits);
        while a >= a_max.get() {
            a = T::random_bits(&mut rng, a_max_bits)
        }
        p = a * m + b;
    }
    p
}

// Calculates three constants, `m`, `λ(m)` and `a_max`, used in the uniform sieving algorithms.
// `m` is the product of all odd primes such that the product fits in a `T`.
// `λ(m)`, aka Carmichael's function is the LCM of the λ(p)s for each prime used to compute m. In
// our case, each λ(p) is simply p-1 because each prime appears once (and we exclude 2).
// `a_max` is the upper bound on the part of a prime candidate that is re-randomized on each iteration and set to 2^n/m -1
// Constant values for common `T`s sized from 32 to 2028:
// For u32, 9 primes,       m = 0xC0CFD797
//                          λ(m) = 0x0000D890
//                          a_max = 0x153E5645B
// For U64, 15 primes,      m = 0xE221F97C30E94E1D
//                          λ(m) = 0x0000000000FCF030
//                          a_max = 0x000000000000000121CFE6CFC938B36A
// For U128, 25 primes,     m = 0x5797D47C51681549D734E4FC4C3EAF7F
//                          λ(m) = 0x00000000000000000000002DE3CB9560
//                          a_max = 0x00000000000000000000000000000002EC2FD90EC0982A01049B71B59E0BEBD7
// For U256, 43 primes,     m = 0xDBF05B6F5654B3C0F5243551439586889F155887819AED2AC05B93352BE98677
//                          λ(m) = 0x0000000000000000000000000000000000000000000097262FAE1826B96DBE40
//                          a_max = 0x000000000000000000000000000000000000000000000000000000000000000129F942811E1964B5B00B0B16015A8EEA88C7191B2E972CC3A9C9F1BD3BF4A01C
// For U512, 74 primes,     m = 0x106AA9FB7646FA6EB0813C28C5D5F09F077EC3BA238BFB99C1B631A203E81187233DB117CBC384056EF04659A4A11DE49F7ECB29BADA8F980DECECE92E30C48F
//                          λ(m) = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000468A4F19CEA99B05F593F7F03EBA946B4AF700
//                          a_max = 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F980B0BC8CD6E718FFDE5AE0714973483A90B31703570FD0F4D3AF75B7A104188AAFF383B6267C09BDEDC4E3C889A46D39E0E4ABC82611D46631FD36F36B760B7
// For U1024, 130 primes,   m = 0x02C85FF870F24BE80F62B1BA6C20BD72B837EFDF121206D87DB56B7D69FA4C021C107C3CA206FE8FA7080EF576EFFC82F9B10F5750656B7794B16AFD70996E91AEF6E0AD15E91B071AC9B24D98B233AD86EE055518E58E56638EF18BAC5C74CB35BBB6E5DAE2783DD1C0CE7DEC4FC70E5186D411DF36368F061AA36011F30179
//                          λ(m) = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009220E37A82CBB6007A9DEE07DE852B1FD11D7594688264F7F40E71355F33B7EBFC100
//                          a_max = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005BFF1AFC23D09D75DEDE879115527714867E2D48B0A105AC642B99C0B539A8331BCD4ADC7FE2B37FD0E1D5422305EE5CDE57882ACF567FC77E6847C47ED3802E74EE0C05F9E5727E4797737D9A5B5FF10BC23BCCA027A43EC75D8F115677DA1F650DF093CA66A0FB46357E0EE79B50C2381EC61CB4F2250EED7FB80DDD219F86AE
// For U2048, 232 primes,   m = 0x2465A7BD85011E1C9E0527929FFF268C82EF7EFA416863BAA5ACDB0971DBA0CCAC3EE4999345029F2CF810B99E406AAC5FCE5DD69D1C717DAEA5D18AB913F456505679BC91C57D46D9888857862B36E2EDE2E473C1F0AB359DA25271AFFE15FF240E299D0B04F4CD0E4D7C0E47B1A7BA007DE89AAE848FD5BDCD7F9815564EB060AE14F19CB50C291F0BBD8ED1C4C7F8FC5FBA51662001939B532D92DAC844A8431D400C832D039F5F900B278A75219C2986140C79045D7759540854C31504DC56F1DF5EEBE7BEE447658B917BF696D6927F2E2428FBEB340E515CB9835D63871BE8BBE09CF13445799F2E67788151571A93B4C1EEE55D1B9072E0B2F5C4607F
//                          λ(m) = 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000099F002D0502D70DF7B64150D19B477A781987C56EBCDB7637842794D22D0D022010DC9BA1DB141FC9D07A9587E7A130D9DF6F9B67812800D00
//                          a_max = 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000708955E50C5F9A609A797793B1E155517918D6A5537DC62F21D44D8DE025D4D2936ED0EC76AB086E7725EF62D185C61607BF006F017521BE5C249C24A6809A2B389BB614AFD09A32FB39B58881869396DFE87BC8957BBBE2EE8E7E0B551B0EC3C93DB35A95C541637D3A2566DECCA46512BA640192980BD5EE0619E8790206EE416F78E6B7B0AAE3C90A195A574663F9BAE4195B0DA9F0C73843460F4B0068747B57FDE77319FF7CE46A7039137FA7FB58FE0F88B964CAF66038843AA52A0114105118DFF6BD50C40FBBFF9FA5CBB181EE3D7AD3D055C5A85B49CFD989AC31B3338C3DF660C708AEB65376D65B67C1580436235BDA8CC5989BD4102900150626A

// TODO(dp): Would love for this to be `const`. Or not here at all. Does it have any value, in some form?
#[allow(unused)]
fn calculate_constants<T, WT>() -> (T, T, WT)
where
    T: FixedInteger + crypto_bigint::Gcd<Output = T>,
    WT: FixedInteger + From<(T, T)>,
{
    let mut m = T::ONE;
    let mut lambda_m = T::ONE;
    for (i, prime) in SMALL_PRIMES.into_iter().enumerate() {
        let prime_t = T::from(prime);
        let prod_overflowed = m.checked_mul(&prime_t);
        if prod_overflowed.is_none().into() {
            break;
        } else {
            m = prod_overflowed.unwrap();
            let p_minus_one = prime_t - T::ONE;
            let gcd = lambda_m.gcd(&p_minus_one);
            let gcd_nz = NonZero::new(gcd).unwrap();
            lambda_m = lambda_m * prime_t.div(gcd_nz);
        }
    }
    let wide_m = WT::from((m, T::ZERO));
    let a_max = WT::MAX.div(NonZero::new(wide_m).unwrap()) - WT::ONE;
    (m, lambda_m, a_max)
}

// Special case for u32s, given crypto-bigint does not provide such small uints.
#[allow(unused)]
fn calculate_constants_u32() -> (u32, u32, u64) {
    // The product of the 9 first odd primes fits in a u32
    // Primes: 3, 5, 7, 11, 13, 17, 19, 23, 29
    let (m, lambda_m) = SMALL_PRIMES[..9].iter().fold((1u32, 1u64), |mut acc, p| {
        acc.0 = acc.0.checked_mul(*p as u32).unwrap();
        let lambda_p = {
            let p_minus_one: u64 = *p as u64 - 1;
            let gcd = binary_gcd(acc.1, p_minus_one);
            acc.1 * (*p as u64 / gcd)
        };

        acc.1 = lambda_p;
        acc
    });
    let a_max = (u64::MAX / m as u64) - 1;
    (m, lambda_m as u32, a_max)
}

#[cfg(test)]
mod tests {
    use super::*;
    use core::ops::Div;
    use crypto_bigint::{U1024, U128, U2048, U256, U512, U64};
    use tracing::{debug, info};
    #[test_log::test]
    fn debug_algo2() {
        type T = U64;
        let hex_m = "00000000C0CFD797";
        let hex_lambda_m = "000000000000D890";
        let m = T::from_be_hex(hex_m);
        let lambda_m = T::from_be_hex(hex_lambda_m);
        let unit = jp06_unitgen(m, lambda_m);

        let mut count = 0u64;
        let mut start = std::time::Instant::now();
        let m_nz = NonZero::new(m).expect("m is known, pre-calculated, non-zero, odd value");
        let a_max =
            NonZero::new(T::MAX.div(m_nz) - T::ONE).expect("m is known, pre-calculated, non-zero, odd, larger than 1");
        info!("a_max={a_max:?}");
        loop {
            // let _ = algorithm2(unit, m, &a_max);
            // This is 4x faster than `algorithm2`
            let _ = algorithm2_faster_but_why(unit, m, &a_max);
            count += 1;
            if count % 10_000 == 0 {
                debug!("10k iters in {:?}", start.elapsed());
                start = std::time::Instant::now();
            }
        }
    }
    // This isn't actually a test, just here to generate constants
    #[test_log::test]
    fn generate_constants() {
        let (m, lambda_m, a_max) = calculate_constants_u32();
        info!("32 bits: m=0x{m:X?}, lambda_m=0x{lambda_m:X?}, a_max=0x{a_max:X?}");

        let (m, lambda_m, a_max) = calculate_constants::<U64, U128>();
        info!("64 bits: m={m:?}, lambda_m={lambda_m:?}, a_max={a_max:?}");

        let (m, lambda_m, a_max) = calculate_constants::<U128, U256>();
        info!("128 bit: m={m:?}, lambda_m={lambda_m:?}, a_max={a_max:?}");

        let (m, lambda_m, a_max) = calculate_constants::<U256, U512>();
        info!("256 bits: m={m:?}, lambda_m={lambda_m:?}, a_max={a_max:?}");

        let (m, lambda_m, a_max) = calculate_constants::<U512, U1024>();
        info!("512 bit: m={m:?}, lambda_m={lambda_m:?}, a_max={a_max:?}");

        let (m, lambda_m, a_max) = calculate_constants::<U1024, U2048>();
        info!("1024 bits: m={m:?}, lambda_m={lambda_m:?}, a_max={a_max:?}");

        let (m, lambda_m, a_max) = calculate_constants::<U2048, U4096>();
        info!("2048 bit: m={m:?}, lambda_m={lambda_m:?}, a_max={a_max:?}");
    }
    #[test_log::test]
    fn genprime() {
        let p: U64 = U64::generate_prime();
        info!("64 bit prime={p:?}");
        let p = U128::generate_prime();
        info!("128 bit prime={p:?}");
        let p = U256::generate_prime();
        info!("256 bit prime={p:?}");
        let p = U512::generate_prime();
        info!("512 bit prime={p:?}");
        let p = U1024::generate_prime();
        info!("1024 bit prime={p:?}");
        let p = U2048::generate_prime();
        info!("2048 bit prime={p:?}");
        // This is very slow
        let p = U4096::generate_prime();
        info!("4096 bit prime={p:?}");
    }

    // TODO(dp): test for statisical properties
    #[test_log::test]
    fn entropy() {
        // Let x = 2^k, and let Mk be the set of odd numbers in the interval [x/2..x[, i.e. the set
        // of odd numbers of bit length precisely k.
        // The optimal output distribution of primes is the uniform distribution over the primes in Mk, since
        // it has maximal entropy. By the prime number theorem, this maximal value is about
        //      Hmax(x) = log(x/(2*log(x)) for large x.

        // Theorem 1.
        // Let H be the entropy of the output distribution.
        // Let Hmax be the maximal possible value of H.
        // Then, under Hardy and Littlewoods’ prime r-tuple conjecture[11] and Gallagher’s
        // heuristic[10], we have for any n >= 256:
        //      Hmax − H < (1−γ) / ln 2 < 0.609949
        // where γ is the Euler-Mascheroni constant[22].
    }
}
